{"pages":[],"posts":[{"title":"我的第一个博客!","text":"经历4次重装，不搞花里胡哨的改主题，我终于能加载出博客了，大概准备用来记录一些日常生活，学习笔记，嘿嘿，欢迎关注我鸭！ 更新频率：一周一次使用git更新博客的方法创建一篇新的博客–法一1$ hexo new \"My New Post\"//引号中为创建的名字 创建一篇新的博客–法二1直接在_posts文件中新建一个文本文件，再更改为md文件 运行 server1$ hexo server//可以不用 生成静态文件1$ hexo generate//缩写g 部署到远程站点1$ hexo deploy//缩写d More info: 博客创建","link":"/2019/10/26/MY%20first%20blog/"},{"title":"堆栈模拟队列","text":"title: 队列tags:categories: 算法comments: false7-2 堆栈模拟队列 设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。 所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数: int IsFull(Stack S)：判断堆栈S是否已满，返回1或0； int IsEmpty (Stack)：判断堆栈S是否为空，返回1或0； void Push(Stack S, ElementType item )：将元素item压入堆栈S； ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。 输入格式:输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。 输出格式:对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。 输入样例:3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T输出样例:ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty思路几种情况记容量小的栈为s1，容量大的栈为s2 输入时 s1没满，s2为空，输入到s1中。 s1满了，s2为空，将s1中的数据倒入s2中，再输入到s1中。 s1满了，s2不为空，输出ERROR:Full。输出时 s2不是空的，直接输出s2.top()。 s2是空的，s1不是空的，将s1中的元素倒入s2中，再输出s2.top()。 s2是空的，s1也是空的，输出ERROR:Empty。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*提交时间 状态 分数 题目 编译器 耗时 用户2018/7/13 15:15:48 答案正确 25 7-22 C++ (g++) 5 ms 17204111测试点 结果 耗时 内存0 答案正确 4 ms 404KB1 答案正确 4 ms 404KB2 答案正确 5 ms 380KB*/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main(){ stack&lt;int&gt;s1; stack&lt;int&gt;s2; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; if (v1 &gt; v2) { v1 ^= v2; v2 ^= v1; v1 ^= v2; } int num; char order; while (true) { cin &gt;&gt; order; if (order == &apos;T&apos;) exit(0); else if (order==&apos;A&apos;) { cin &gt;&gt; num; if (s1.size() == v1) { if (s2.size() == 0) { while (s1.size()) { s2.push(s1.top()); s1.pop(); } s1.push(num); } else { cout &lt;&lt; &quot;ERROR:Full&quot; &lt;&lt; endl; continue; } } else { s1.push(num); } } else if (order == &apos;D&apos;) { if (s2.size() == 0) { if (s1.size() == 0) { cout &lt;&lt; &quot;ERROR:Empty&quot; &lt;&lt; endl; continue; } else { while (s1.size()) { s2.push(s1.top()); s1.pop(); } } } cout &lt;&lt; s2.top() &lt;&lt; endl; s2.pop(); } }}","link":"/2019/11/11/%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"}],"tags":[],"categories":[{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}