{"pages":[],"posts":[{"title":"我的第一个博客!","text":"经历4次重装，不搞花里胡哨的改主题，我终于能加载出博客了，大概准备用来记录一些日常生活，学习笔记，嘿嘿，欢迎关注我鸭！ 更新频率：一周一次使用git更新博客的方法创建一篇新的博客–法一1$ hexo new \"My New Post\"//引号中为创建的名字 创建一篇新的博客–法二1直接在_posts文件中新建一个文本文件，再更改为md文件 运行 server1$ hexo server//可以不用 生成静态文件1$ hexo generate//缩写g 部署到远程站点1$ hexo deploy//缩写d More info: 博客创建","link":"/2019/10/26/MY%20first%20blog/"},{"title":"python爬虫学习day01","text":"![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) python课程python能够应用的领域非常宽泛12345678910111213141516171819202122232425262728293031\"\"\"学习爬虫之前需要先学习python的基本语法、数据类型、函数、模块、内置方法、类、正则表达式人工智能机器学习数据分析金融量化爬虫自动化运维/测试web开发...全栈 前端后端都自己写 前端 html css js jQuery bootstrap vue element-UI 后端 python django flask tornado fastapi sanic\"\"\" 什么是语言、什么是编程语言、为何要有编程语言1234567\"\"\"语言:语言其实就是人与人之间沟通交流的媒介 汉语、日语、法语编程语言:人与计算机之间沟通交流的媒介为何要有编程语言: 因为在编程的世界里、计算机就好比是人的奴隶,人与计算机沟通的目的就是为了奴役计算机。让计算机按照人类的思维逻辑自发的去工作从而解放人力 计算机(电脑)\"\"\" 什么是编程1234567891011\"\"\"编程:人将自己的思维逻辑和想法用编程语言的形式写下来的过程 (写代码其实就是在将自己的想法表达出来的过程)其实学编程语言跟学英文、法语等其他语言一样的 你可以将python看成是一门鸟语 变量 数据类型 流程控制 函数/类\"\"\" 计算机五大组成部分1234567891011121314151617181920212223242526272829303132333435# 你可以将计算机看成就是一个人\"\"\"学枯燥乏味知识点的时候 可以多运用比喻的手法 将知识点结合日常生活中的例子\"\"\"1.控制器 控制器是计算机的指挥系统，用来控制计算机其他组件的运行，相当于人的大脑2.运算器 运算器是计算机的运算功能，用来做算术运算和逻辑运算，相当于人的大脑 算术运算 数学运算 逻辑运算 事物的对错 控制器 + 运算器 = 中央处理器(CPU)3.存储器 存储器是计算机的记忆功能，用来存取数据 内存:相当于人的短期记忆 断电之后数据立刻丢失 外存:相当于记事本 断电数据也不会丢失 是用来永久保存数据的方法 硬盘、磁带、磁盘 磁带:随身听 磁盘:服务器数据备份 内存的存取速度要比外存快的多 4.输入设备input 计算机接收外界输入数据的工具 键盘、鼠标 类似于人的眼睛、耳朵 5.输出设备output 计算机向外输出数据的工具 显示器、打印机 类似于人的说话、写字存储器如内存、磁盘等即是输入设备又是输出设备，这一类设备我们通常称之为IO设备 操作系统123456789101112131415161718192021222324252627282930313233# windows linux mac uninx ubuntu\"\"\"大前提:计算机是不会帮你自动做任何一件事情的 无论事情有多么的小(二极管的开通关闭)也就是说如果我们需要开发一个应用程序 我们就需要先写一段操作计算机硬件的代码，然后才能写真正应用程序代码程序员A开发快播 1.先书写操作计算机硬件的代码(10年) 2.才能书写快播程序代码(1s)程序员B开发迅雷 1.先书写操作计算机硬件的代码(10年) 2.才能书写迅雷程序代码(1s)程序员C开发西瓜 1.先书写操作计算机硬件的代码(10年) 2.才能书写西瓜程序代码(1s)上述问题 1.重复动作 2.耗时巨大 你还不一定能写出来 计算机硬件太多了 操作系统 封装了所有操作计算机硬件的复杂程序 暴露给用户简单方便的可以操作计算机硬件的接口 应用程序只需要按照接口规范就可以(间接)操作计算机硬件\"\"\"# 计算机系统三层架构 1.应用程序 2.操作系统 3.计算机硬件操作系统其实也是应用程序，只不过它是专门跟计算机硬件打交道的应用程序而已 编程语言12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 编程语言发展史 1.机器语言(站在了奴隶的角度说奴隶能够直接听懂的语言) 计算机能够直接读懂 计算机只能够识别010101的二进制数据 0101010101010101010 2.汇编语言(站在了奴隶的角度说奴隶能够直接听懂的语言) 用英文标签代表一组二进制指令 a 01010101010 3.高级语言(站在奴隶主角度说人能够理解语言) python、java、php、C++、C## # 如何解决计算机看不懂的问题 高级语言 翻译官 计算机 # 翻译官1.编译型 C++ 类似于谷歌翻译 一次性翻译所有2.解释型 Python 类似于同声传译 说一句翻译一句 # python解释器在IT界千万不要轻易的尝试最新版本的软件、模块、框架等 更新完没事 还是普通员工 更新完出事 就变成\"烈士\"\"\"\"目前有两大版本 python2 python2.7最后的版本 2020年已经不再更新维护 python3 推荐使用python3.6版本 百度搜python解释器 找官网\"\"\"# python简介 python是龟叔在圣诞节的时候在家里闲着没事干 无聊打发时间开发的 python能够兼容C和shell语法的特点 # python解释器种类\"\"\"CPython 使用最广泛的是CPythonJpythonPyPython\"\"\" # 安装IDE开发工具 1.pycharm 2.vscode 建议安装pycharm 1.安装专业版 2.破解 1.激活码破解 百度搜索 网址: 淘宝: 2.解压我分享的文件 将.jar结尾的文件拖入pycharm窗口 点击安装 激活即可 3.搜索软件 作业1231.安装python解释器 自己研究python多版本共存2.安装pycharm编辑器 成功激活并使用3.预习博客python基础内容","link":"/2020/06/22/pythonday01/"},{"title":"STL库（C++）","text":"STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，不用单独安装。C++对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表（数组），list的底层为双向链表，deque 的底层为循环队列，set的底层为红黑树，hash_set的底层为哈希表。string类&nbsp;&nbsp;&nbsp;&nbsp;字符串的表现形式多种多样，如TCHAR，std::string、BSTR 等。字符串类均起源于C语言的字符串，而最初C语言的字符串是字符的数组。单字节字符串顺序存放各个字符串，并用 \\0 表示字符串的结束。在C语言中，已存在部分字符串处理函数，例如 strcpy()，sprintf() ,stoi() 等，只能用于单字节字符串。在标准库中，还有仅用于 Unicode 字符串的函数，如wcscpy()，swprintf() , _wtol() 等。 多数人都惯于使用指针 ++ 和-- 操作符来遍历字符串。使用数组处理字符串中的字符也非常方便。无论ASCII码字符串还是Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。 STL 中只有一个字符串类，即basic_string。类 basic_string 实现管理以 \\0 结尾的字符数组，字符类型由模板参数决定。 通常，basic_string 被处理为不透明的对象，靠获得只读指针来访问缓冲区，写操作是由 basic_string 的成员函数实现的。STL 的 C++ 标准程序库中的 string 类，使用时不必担心内存是否充足、字符串长度等问题。 string作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。 1.要使用 string 类，必须包含头文件&lt;string&gt;。在 STL 库中，basic_string有两个预定义类型：包含 char 的 string 类型和包含wchar 的wstring类型。 2.string 类的 string::npos 可同时定义字符串的最大长度，通常设置为无符号 int 的最大值。string 类包含了 6 个构造函数。 3.string 类支持 cin 方式和 getline() 方式两种输入方式。简单示例如下： 123string stuff;cin &gt;&gt; stuff;getline(cin, stuff); 上述三行代码，第一行是声明 string 类的对象 stuff，第二行是从屏幕读入输入的字符串，第三行同样实现第二行代码的功能。 4.string 库提供了许多其他功能，如删除字符串的部分或全部，用一个字符的部分或全部替换另一个字符串的部分或全部，插入、删除字符串中数据，比较、提取、复制、交换等。 C++ auto_ptr类（智能指针）该类主要用于管理动态内存分配。1.如果使用 new()函数分配堆中的内存，而又不记得回收这部分内存，会导致内存泄漏。因此必须使用 delete 语句释放该内存块。即使在函数末端添加了delete 语句释放内存，还需要在任何跳出该函数的语句（如抛出异常）之前添加释放内存的处理，例如 goto 语句和 throw 语句。 auto_ptr 模板定义了类似指针的对象，将 new 获得的地址赋给该对象。当 auto_ptr 对象过期时，析构函数将使用 delete 来释放内存。如果将 new 返回的地址赋值给 auto_ptr 对象，无须记住还需要释放这些内存。在 auto_ptr 对象过期时，内存将自动被释放。 在 C++ 语言中，要使用 STL 中的 auto_ptr 对象， 2.必须包含头文件 ，该文件包括 auto_ptr 模板。使用通常的模板句法来实例化所需类型的指针。auto_ptr 构造函数是显式的，不存在从指针到 auto_ptr 对象的隐式类型转换。 123456auto_ptr &lt;double&gt; pd;double *p_reg = new double;pd = p_reg; // 不允许pd = auto_ptr &lt;double&gt; (p_reg); //允许auto_ptr &lt;double&gt; panto =p_reg; //不允许auto_ptr &lt;double&gt; pauto (p_reg); //允许 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板可以通过构造函数将 auto_ptr 对象初始化为一个常规指针。auto_ptr 是一个智能指针，但其特性远比指针要多。值得注意的是，在使用 auto_ptr 时，只能配对使用 new 和 delete。提示，只能对 new 分配的内存使用 auto_ptr 对象，不要对由 new() 分配的或通过声明变量分配的内存使用它。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ 库中的 auto_ptr 对象是一种智能指针。智能指针是一种类，即其对象的特征结类似于指针。智能指针存储 new 分配的内存地址，也可以被解除引用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能指针是一个类对象，可以修改和扩充简单指针的行为。智能指针可以建立引用计数，这使得多个对象可共享由智能指针跟踪的同一个值。当使用该值的对象数为 0 时，智能指针将删除该值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能指针可以提高内存的使用效率，帮助防止内存泄露。","link":"/2019/11/22/STL%E5%BA%93/"},{"title":"7-2 堆栈模拟队列","text":"7-2 堆栈模拟队列设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。 所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数: int IsFull(Stack S)：判断堆栈S是否已满，返回1或0； int IsEmpty (Stack)：判断堆栈S是否为空，返回1或0； void Push(Stack S, ElementType item )：将元素item压入堆栈S； ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。 输入格式:输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。 输出格式:对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。 输入样例:3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T输出样例:ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty思路几种情况记容量小的栈为s1，容量大的栈为s2 输入时 s1没满，s2为空，输入到s1中。 s1满了，s2为空，将s1中的数据倒入s2中，再输入到s1中。 s1满了，s2不为空，输出ERROR:Full。输出时 s2不是空的，直接输出s2.top()。 s2是空的，s1不是空的，将s1中的元素倒入s2中，再输出s2.top()。 s2是空的，s1也是空的，输出ERROR:Empty。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*提交时间 状态 分数 题目 编译器 耗时 用户2018/7/13 15:15:48 答案正确 25 7-22 C++ (g++) 5 ms 17204111测试点 结果 耗时 内存0 答案正确 4 ms 404KB1 答案正确 4 ms 404KB2 答案正确 5 ms 380KB*/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main(){ stack&lt;int&gt;s1; stack&lt;int&gt;s2; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; if (v1 &gt; v2) { v1 ^= v2; v2 ^= v1; v1 ^= v2; } int num; char order; while (true) { cin &gt;&gt; order; if (order == &apos;T&apos;) exit(0); else if (order==&apos;A&apos;) { cin &gt;&gt; num; if (s1.size() == v1) { if (s2.size() == 0) { while (s1.size()) { s2.push(s1.top()); s1.pop(); } s1.push(num); } else { cout &lt;&lt; &quot;ERROR:Full&quot; &lt;&lt; endl; continue; } } else { s1.push(num); } } else if (order == &apos;D&apos;) { if (s2.size() == 0) { if (s1.size() == 0) { cout &lt;&lt; &quot;ERROR:Empty&quot; &lt;&lt; endl; continue; } else { while (s1.size()) { s2.push(s1.top()); s1.pop(); } } } cout &lt;&lt; s2.top() &lt;&lt; endl; s2.pop(); } }}","link":"/2019/11/11/%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"title":"C/C++头文件超全整理","text":"万能头文件：#include &lt;bits/stdc++.h&gt; 包含c/c++中的所有头文件，但这个好像并不是所有的oj平台都能用 C++常用1.#include 用途：数学函数比如sqrt 2.#include 用途： strlen 计算字符串的长度 strcpy拷贝 memcpy3.#include 算法（Algorithm）为一个计算的具体步骤，常用于计算、数据处理和自动推理。C++ 算法库（Algorithms library）为 C++ 程序提供了大量可以用来对容器及其它序列进行算法操作的函数。这些组件可以为函数或函数模板，大部份由头文件 提供，一小部份位于 、 中。 用途： 4.#include &lt;stdio.h&gt;用途：","link":"/2019/11/22/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B6%85%E5%85%A8%E6%95%B4%E7%90%86/"},{"title":"队列题","text":"title: 队列tags: PTAcategories: 算法comments: false 7-2 堆栈模拟队列设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。 所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数: int IsFull(Stack S)：判断堆栈S是否已满，返回1或0； int IsEmpty (Stack)：判断堆栈S是否为空，返回1或0； void Push(Stack S, ElementType item )：将元素item压入堆栈S； ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。 输入格式:输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。 输出格式:对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。 输入样例:3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T输出样例:ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty思路几种情况记容量小的栈为s1，容量大的栈为s2 输入时 s1没满，s2为空，输入到s1中。 s1满了，s2为空，将s1中的数据倒入s2中，再输入到s1中。 s1满了，s2不为空，输出ERROR:Full。输出时 s2不是空的，直接输出s2.top()。 s2是空的，s1不是空的，将s1中的元素倒入s2中，再输出s2.top()。 s2是空的，s1也是空的，输出ERROR:Empty。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*提交时间 状态 分数 题目 编译器 耗时 用户2018/7/13 15:15:48 答案正确 25 7-22 C++ (g++) 5 ms 17204111测试点 结果 耗时 内存0 答案正确 4 ms 404KB1 答案正确 4 ms 404KB2 答案正确 5 ms 380KB*/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main(){ stack&lt;int&gt;s1; stack&lt;int&gt;s2; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; if (v1 &gt; v2) { v1 ^= v2; v2 ^= v1; v1 ^= v2; } int num; char order; while (true) { cin &gt;&gt; order; if (order == &apos;T&apos;) exit(0); else if (order==&apos;A&apos;) { cin &gt;&gt; num; if (s1.size() == v1) { if (s2.size() == 0) { while (s1.size()) { s2.push(s1.top()); s1.pop(); } s1.push(num); } else { cout &lt;&lt; &quot;ERROR:Full&quot; &lt;&lt; endl; continue; } } else { s1.push(num); } } else if (order == &apos;D&apos;) { if (s2.size() == 0) { if (s1.size() == 0) { cout &lt;&lt; &quot;ERROR:Empty&quot; &lt;&lt; endl; continue; } else { while (s1.size()) { s2.push(s1.top()); s1.pop(); } } } cout &lt;&lt; s2.top() &lt;&lt; endl; s2.pop(); } }}","link":"/2019/11/22/%E9%98%9F%E5%88%97%E9%A2%98/"}],"tags":[{"name":"杂记","slug":"杂记","link":"/tags/%E6%9D%82%E8%AE%B0/"},{"name":"python爬虫","slug":"python爬虫","link":"/tags/python%E7%88%AC%E8%99%AB/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"头文件","slug":"头文件","link":"/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"}],"categories":[{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}