{"pages":[],"posts":[{"title":"分类测试","text":"","link":"/2019/11/22/test/"},{"title":"我的第一个博客!","text":"经历4次重装，不搞花里胡哨的改主题，我终于能加载出博客了，大概准备用来记录一些日常生活，学习笔记，嘿嘿，欢迎关注我鸭！ 更新频率：一周一次使用git更新博客的方法创建一篇新的博客–法一1$ hexo new \"My New Post\"//引号中为创建的名字 创建一篇新的博客–法二1直接在_posts文件中新建一个文本文件，再更改为md文件 运行 server1$ hexo server//可以不用 生成静态文件1$ hexo generate//缩写g 部署到远程站点1$ hexo deploy//缩写d More info: 博客创建","link":"/2019/10/26/MY%20first%20blog/"},{"title":"STL库（C++）","text":"STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，不用单独安装。C++对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表（数组），list的底层为双向链表，deque 的底层为循环队列，set的底层为红黑树，hash_set的底层为哈希表。string类&nbsp;&nbsp;&nbsp;&nbsp;字符串的表现形式多种多样，如TCHAR，std::string、BSTR 等。字符串类均起源于C语言的字符串，而最初C语言的字符串是字符的数组。单字节字符串顺序存放各个字符串，并用 \\0 表示字符串的结束。在C语言中，已存在部分字符串处理函数，例如 strcpy()，sprintf() ,stoi() 等，只能用于单字节字符串。在标准库中，还有仅用于 Unicode 字符串的函数，如wcscpy()，swprintf() , _wtol() 等。 多数人都惯于使用指针 ++ 和-- 操作符来遍历字符串。使用数组处理字符串中的字符也非常方便。无论ASCII码字符串还是Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。 STL 中只有一个字符串类，即basic_string。类 basic_string 实现管理以 \\0 结尾的字符数组，字符类型由模板参数决定。 通常，basic_string 被处理为不透明的对象，靠获得只读指针来访问缓冲区，写操作是由 basic_string 的成员函数实现的。STL 的 C++ 标准程序库中的 string 类，使用时不必担心内存是否充足、字符串长度等问题。 string作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。 1.要使用 string 类，必须包含头文件&lt;string&gt;。在 STL 库中，basic_string有两个预定义类型：包含 char 的 string 类型和包含wchar 的wstring类型。 2.string 类的 string::npos 可同时定义字符串的最大长度，通常设置为无符号 int 的最大值。string 类包含了 6 个构造函数。 3.string 类支持 cin 方式和 getline() 方式两种输入方式。简单示例如下： 123string stuff;cin &gt;&gt; stuff;getline(cin, stuff); 上述三行代码，第一行是声明 string 类的对象 stuff，第二行是从屏幕读入输入的字符串，第三行同样实现第二行代码的功能。 4.string 库提供了许多其他功能，如删除字符串的部分或全部，用一个字符的部分或全部替换另一个字符串的部分或全部，插入、删除字符串中数据，比较、提取、复制、交换等。 C++ auto_ptr类（智能指针）该类主要用于管理动态内存分配。1.如果使用 new()函数分配堆中的内存，而又不记得回收这部分内存，会导致内存泄漏。因此必须使用 delete 语句释放该内存块。即使在函数末端添加了delete 语句释放内存，还需要在任何跳出该函数的语句（如抛出异常）之前添加释放内存的处理，例如 goto 语句和 throw 语句。 auto_ptr 模板定义了类似指针的对象，将 new 获得的地址赋给该对象。当 auto_ptr 对象过期时，析构函数将使用 delete 来释放内存。如果将 new 返回的地址赋值给 auto_ptr 对象，无须记住还需要释放这些内存。在 auto_ptr 对象过期时，内存将自动被释放。 在 C++ 语言中，要使用 STL 中的 auto_ptr 对象， 2.必须包含头文件 ，该文件包括 auto_ptr 模板。使用通常的模板句法来实例化所需类型的指针。auto_ptr 构造函数是显式的，不存在从指针到 auto_ptr 对象的隐式类型转换。 123456auto_ptr &lt;double&gt; pd;double *p_reg = new double;pd = p_reg; // 不允许pd = auto_ptr &lt;double&gt; (p_reg); //允许auto_ptr &lt;double&gt; panto =p_reg; //不允许auto_ptr &lt;double&gt; pauto (p_reg); //允许 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板可以通过构造函数将 auto_ptr 对象初始化为一个常规指针。auto_ptr 是一个智能指针，但其特性远比指针要多。值得注意的是，在使用 auto_ptr 时，只能配对使用 new 和 delete。提示，只能对 new 分配的内存使用 auto_ptr 对象，不要对由 new() 分配的或通过声明变量分配的内存使用它。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ 库中的 auto_ptr 对象是一种智能指针。智能指针是一种类，即其对象的特征结类似于指针。智能指针存储 new 分配的内存地址，也可以被解除引用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能指针是一个类对象，可以修改和扩充简单指针的行为。智能指针可以建立引用计数，这使得多个对象可共享由智能指针跟踪的同一个值。当使用该值的对象数为 0 时，智能指针将删除该值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能指针可以提高内存的使用效率，帮助防止内存泄露。","link":"/2019/11/22/STL%E5%BA%93/"},{"title":"C/C++头文件超全整理","text":"万能头文件：#include &lt;bits/stdc++.h&gt; 包含c/c++中的所有头文件，但这个好像并不是所有的oj平台都能用 C++常用1.#include 用途：数学函数比如sqrt 2.#include 用途： strlen 计算字符串的长度 strcpy拷贝 memcpy3.#include 算法（Algorithm）为一个计算的具体步骤，常用于计算、数据处理和自动推理。C++ 算法库（Algorithms library）为 C++ 程序提供了大量可以用来对容器及其它序列进行算法操作的函数。这些组件可以为函数或函数模板，大部份由头文件 提供，一小部份位于 、 中。 用途： 4.#include &lt;stdio.h&gt;用途：","link":"/2019/11/22/%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B6%85%E5%85%A8%E6%95%B4%E7%90%86/"},{"title":"7-2 堆栈模拟队列","text":"7-2 堆栈模拟队列设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。 所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数: int IsFull(Stack S)：判断堆栈S是否已满，返回1或0； int IsEmpty (Stack)：判断堆栈S是否为空，返回1或0； void Push(Stack S, ElementType item )：将元素item压入堆栈S； ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。 输入格式:输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。 输出格式:对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。 输入样例:3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T输出样例:ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty思路几种情况记容量小的栈为s1，容量大的栈为s2 输入时 s1没满，s2为空，输入到s1中。 s1满了，s2为空，将s1中的数据倒入s2中，再输入到s1中。 s1满了，s2不为空，输出ERROR:Full。输出时 s2不是空的，直接输出s2.top()。 s2是空的，s1不是空的，将s1中的元素倒入s2中，再输出s2.top()。 s2是空的，s1也是空的，输出ERROR:Empty。 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*提交时间 状态 分数 题目 编译器 耗时 用户2018/7/13 15:15:48 答案正确 25 7-22 C++ (g++) 5 ms 17204111测试点 结果 耗时 内存0 答案正确 4 ms 404KB1 答案正确 4 ms 404KB2 答案正确 5 ms 380KB*/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main(){ stack&lt;int&gt;s1; stack&lt;int&gt;s2; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; if (v1 &gt; v2) { v1 ^= v2; v2 ^= v1; v1 ^= v2; } int num; char order; while (true) { cin &gt;&gt; order; if (order == &apos;T&apos;) exit(0); else if (order==&apos;A&apos;) { cin &gt;&gt; num; if (s1.size() == v1) { if (s2.size() == 0) { while (s1.size()) { s2.push(s1.top()); s1.pop(); } s1.push(num); } else { cout &lt;&lt; &quot;ERROR:Full&quot; &lt;&lt; endl; continue; } } else { s1.push(num); } } else if (order == &apos;D&apos;) { if (s2.size() == 0) { if (s1.size() == 0) { cout &lt;&lt; &quot;ERROR:Empty&quot; &lt;&lt; endl; continue; } else { while (s1.size()) { s2.push(s1.top()); s1.pop(); } } } cout &lt;&lt; s2.top() &lt;&lt; endl; s2.pop(); } }}","link":"/2019/11/11/%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"}],"tags":[],"categories":[{"name":"hexo                       （这个就是文章的分类了）","slug":"hexo-（这个就是文章的分类了）","link":"/categories/hexo-%EF%BC%88%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E6%96%87%E7%AB%A0%E7%9A%84%E5%88%86%E7%B1%BB%E4%BA%86%EF%BC%89/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}